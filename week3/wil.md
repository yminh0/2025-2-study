# <백엔드 스터디 3주차 WIL>
## 레포지토리 계층
### Repository
데이터 베이스에 접근하여 CRUD 작업을 수행하는 계층

Create: 데이터 생성  
Read: 데이터 조회  
Update: 기존 데이터 수정  
Delete: 데이터 삭제

## ORM과 JPA
### JDBC
Java에서 Database에 접근하기 위한 표준화된 API

### SQL을 직접 다루는 방식은 단점이 있다.
반복적인 SQL 코드 작성  
SQL에 의존적인 개발  
객체 - 데이터베이스 간 패러다임 불일치  
=> ORM 사용

### ORM ( Object-Relational Mapping)
객체와 관계형 데이터베이스의 데이터를 자동으로 매핑(연결)해주는 것  

객체 - 데이터베이스 간 패러다임 차이 해결  
반복적인 CRUD SQL 자동으로 처리

### JPA (Java Persistence API)
자바 진영의 ORM 기술 표준  
자바에서 객체를 데이터베이스에 저장하고 관리하기 위한 인터페이스와 기능을 제공하는 API  
대표적인 JPA 구현체는 Hibernate
<img width="1065" height="635" alt="Image" src="https://github.com/user-attachments/assets/81e34ed6-2eb6-4371-8495-acee3ed8d82c" />

## JPA의 동작 방식
### EntityManager
엔티티 객체를 데이터베이스와 연결해주는 창구 역할 (엔티티: 데이터베이스에 저장할 객체)

JPA의 기능 대부분은 엔티티 매니저가 제공  
엔티티 매니저를 사용해서 SQL을 직접 작성하지 않고도 엔티티를 데이터베이스에 등록/수정/조회/삭제 가능  
등록-> em.persist()  
조회-> em.find()  
삭제-> em.remove()

엔티티 매니저는 엔티티를 영속성 컨텍스트에 저장

### 영속성 컨텍스트
JPA에서 엔티티를 관리하기 위해서 만들어져 있는 가상 공간  
엔티티 매니저를 통해 영속성 컨텍스트에 접근

### 엔티티 생명 주기
비영속: 영속성 컨텍스트와 관련 없는 상태  
영속: 영속성 컨텍스트에 저장된 상태. 엔티티가 영속성 컨텍스트에 의해 관리됨  
준영속: 영속성 컨텍스트에 저장되었다가 분리된 상태  
삭제: 영속성 컨텍스트에 엔티티가 삭제될거라고 기록한 상태
<img width="884" height="607" alt="Image" src="https://github.com/user-attachments/assets/1ec3ca67-8153-4106-a541-81298e19d3e2" />

### 영속성 컨텍스트의 특징
#### 1차 캐시  
한 번 조회한 객체를 영속성 컨텍스트가 내부에 저장해두고 재사용하는 구조.    
영속성 컨텍스트에 이미 등록(캐시)된 객체를 조회할 때는 데이터베이스를 거치지 않아도 된다.
#### 동일성 보장  
트랜잭션 안에서는 같은 엔티티를 여러번 조회해도 영속성 컨텍스트에 보관된 같은 객체를 그대로 반환하므로 항상 동일한 객체임이 보장된다.
#### 트랜잭션을 지원하는 쓰기 지연  
데이터베이스에 바로 쓰는 것이 아니라 변경사항들을 모아두었다가 트랜잭션이 완료되는(커밋) 시점에 한 번에 묶어서 DB에 보내는 구조.    
쿼리를 데이터베이스에 한 번에 전달할 수 있으므로 데이터베이스와의 네트워킹 횟수를 줄여 성능을 최적화할 수 있다.
#### 변경 감지
영속성 컨텍스트가 엔티티의 변경 사항을 자동으로 감지하고, 트랜잭션 커밋 시점에 변경 내용을 DB에 반영하는 것.  
변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용

### 트랜잭션
데이터베이스에서 수행되는 작업의 단위  
여러개의 데이터베이스 연산을 하나의 논리적인 작업 단위로 묶어서 실행  
*모든 연산이 성공적으로 수행되면 트랜잭션을 커밋하여 데이터베이스에 반영  
*하나라도 실패하면 롤백하여 이전 상태로 되돌림

### 정리
JPA는 엔티티 매니저를 통해 엔티티를 영속성 컨텍스트라는 공간에서 관리한다.  
변경 내용을 즉시 DB에 반영하지 않고 모아두었다가, 트랜잭션이 커밋될 때 필요한 SQL을 한 번에 실행한다.  
엔티티의 변경을 자동으로 감지해 SQL을 생성하고, 데이터베이스와 동기화를 수행한다.  
이미 조회된 엔티티는 영속성 컨텍스트에 저장되어 동일 트랜잭션 내에서 재사용된다.





